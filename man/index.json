{"UniProtKeywords":{"author":null,"declares":{"name":"UniProtKeywords","parameters":[],"sourceMap":{"File":"annotations.R","Line":"5","Method":{"Method":"UniProtKeywords","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"","examples":null,"keywords":[],"parameters":[],"returns":null,"see_also":null,"title":"Get uniprot keyword background"},"load.human_genes":{"author":null,"declares":{"name":"load.human_genes","parameters":[],"sourceMap":{"File":"uniprot.R","Line":"3","Method":{"Method":"load.human_genes","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"","examples":null,"keywords":[],"parameters":[],"returns":null,"see_also":null,"title":"Load human genes for run single cells for ST data annotation"},"human_genes.annotations":{"author":null,"declares":{"name":"human_genes.annotations","parameters":[{"name":"human.genes","text":"NULL"},{"name":"index","text":"'Bgee'"}],"sourceMap":{"File":"uniprot.R","Line":"10","Method":{"Method":"human_genes.annotations","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":null,"details":null,"examples":null,"keywords":null,"parameters":null,"returns":null,"see_also":null,"title":"human_genes.annotations"},".onLoad":{"author":null,"declares":{"name":".onLoad","parameters":[],"sourceMap":{"File":"zzz.R","Line":"7","Method":{"Method":".onLoad","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":null,"details":null,"examples":null,"keywords":null,"parameters":null,"returns":null,"see_also":null,"title":".onLoad"},"plot_class":{"author":null,"declares":{"name":"plot_class","parameters":[{"name":"spots.class","text":null},{"name":"colors","text":"'paper'"},{"name":"title","text":"'Spatial Spot Class'"},{"name":"padding","text":"'padding: 150px 350px 200px 200px;'"}],"sourceMap":{"File":"class.R","Line":"9","Method":{"Method":"plot_class","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"","examples":null,"keywords":[],"parameters":[{"name":"spots_class","text":"should be a collection of the spot class annotation data or a dataframe object that contains the spot annotation data."}],"returns":null,"see_also":null,"title":"plot spot class map"},"deconv_spatial":{"author":null,"declares":{"name":"deconv_spatial","parameters":[{"name":"expr.mat","text":null},{"name":"n.layers","text":"4"},{"name":"top.genes","text":"1000"},{"name":"alpha","text":"2"},{"name":"beta","text":"0.5"},{"name":"iteration","text":"150"},{"name":"prefix","text":"'class'"},{"name":"make.gene.filters","text":"TRUE"},{"name":"filter.range","text":"[0.05, 0.95]"},{"name":"unify.scale","text":"10"},{"name":"log.norm","text":"TRUE"}],"sourceMap":{"File":"deconv_matrix.R","Line":"27","Method":{"Method":"deconv_spatial","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"the generated expression matrix object could be save as csv matrix by use the function ``geneExpression::write.expr_matrix`` from the GCModeller package.","examples":null,"keywords":[],"parameters":[{"name":"expr_mat","text":"a dataframe object or a GCModeller expression matrix object, the matrix object should be in format of spatial spot in rows and the gene features in columns."},{"name":"n_layers","text":"an integer value for specific the cell layer class number"},{"name":"top_genes","text":"set the number of top genes when export the expression matrix in each cell layers"}],"returns":"A tuple list object that contains multiple result object inside: 1. single_cells: an expression matrix object that contains the single cell data 2. deconv_spatial: an expression matrix object that contains the cell layer deconvolution result data 3. cell_layers: the cell layer composition data 4. gibbs_LDA: the result of the LDA gibbs sampling result outputs, the top features in each cell class","see_also":null,"title":"Make spatial matrix deconvolution Reference-free cell-type deconvolution of pixel-resolution spatially resolved transcriptomics data"},"__spot_class":{"author":null,"declares":{"name":"__spot_class","parameters":[{"name":"cell.layers","text":null},{"name":"color","text":"'paper'"}],"sourceMap":{"File":"deconv_matrix.R","Line":"73","Method":{"Method":"__spot_class","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"use the max value column index as the cell class label","examples":null,"keywords":[],"parameters":[],"returns":null,"see_also":null,"title":"Create spot class annotation"},"single_nmf":{"author":null,"declares":{"name":"single_nmf","parameters":[{"name":"x","text":null},{"name":"dims","text":"9"},{"name":"max.iters","text":"1000"},{"name":"n.threads","text":"8"}],"sourceMap":{"File":"nmf.R","Line":"49","Method":{"Method":"single_nmf","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"NMF has become a powerful tool in the analysis of single-cell genomics data due to its ability to decompose high-dimensional data into a lower-dimensional representation that captures biologically meaningful patterns. In the context of single-cell transcriptomics, for example, NMF can be used to identify distinct cell types or states by clustering the gene expression profiles of individual cells. Here's how NMF is applied in single-cell genomics data analysis: 1. **Data Representation**: Single-cell transcriptomic data is typically presented as a matrix, where rows represent genes and columns represent individual cells. The matrix entries denote the expression levels of genes in cells, often in the form of counts or normalized expression values. 2. **Dimensionality Reduction**: Due to the high dimensionality of single-cell data (tens of thousands of genes per cell), dimensionality reduction techniques like NMF are essential to extract relevant information. NMF reduces the gene expression matrix to a lower-dimensional space by factorizing it into two non-negative matrices: W (basis matrix) and H (coefficients matrix). The basis matrix W represents underlying features (potential cell types or states), while the coefficient matrix H captures the membership strength of each cell to these features. 3. **Biological Interpretation**: The non-negative nature of NMF ensures that the identified features (rows in W) and the cell memberships (columns in H) are composed of non-negative combinations of genes and cells, respectively. This property makes the results more interpretable in a biological context, as the features often correspond to distinct biological states or pathways. 4. **Clustering and Subtyping**: NMF can be used to cluster cells based on their expression profiles. The columns of the coefficient matrix H can be treated as cluster assignments, with each column representing a cell's membership in the discovered features. This allows researchers to identify and annotate different cell types or states present in the dataset. 5. **Differential Expression Analysis**: By comparing the basis matrices obtained from NMF applied to different conditions or treatments, researchers can identify differentially expressed genes that are associated with specific cell states or transitions. 6. **Imputation and Noise Reduction**: NMF can also be used to impute missing values in single-cell data and reduce noise, improving the overall quality of the dataset. 7. **Integration and Alignment**: NMF can be applied to integrate data from different samples or experiments, aligning them to a common feature space and facilitating comparison across conditions. In summary, NMF is a versatile method for the analysis of single-cell genomics data, providing a means to uncover biologically relevant patterns, reduce noise, and integrate information across different samples or conditions. Its non-negative constraints make it particularly suitable for gene expression data, where the interpretation of the factors corresponds to underlying biological processes.","examples":null,"keywords":[],"parameters":[],"returns":null,"see_also":null,"title":"Non-negative Matrix Factorization (NMF) on single cells data"},"plot_pie":{"author":null,"declares":{"name":"plot_pie","parameters":[{"name":"cell.layers","text":null},{"name":"x","text":"NULL"},{"name":"y","text":"NULL"}],"sourceMap":{"File":"pie.R","Line":"11","Method":{"Method":"plot_pie","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"Display the cell\/spot class distribution","examples":null,"keywords":[],"parameters":[{"name":"cell_layers","text":"the cell class probablity matrix data"},{"name":"x","text":"the x axis for draw a pie, could be x scan location of the spatial data or x dimension of the single cells umap embedding result."},{"name":"y","text":"the y axis for draw a pie, could be y scan location of the spatial data or y dimension of the single cells umap embedding result."}],"returns":null,"see_also":null,"title":"Plot the scatter pie data"},"vae_embedding":{"author":null,"declares":{"name":"vae_embedding","parameters":[{"name":"x","text":null},{"name":"dims","text":"9"},{"name":"batch.size","text":"100"},{"name":"iterations","text":"1000"}],"sourceMap":{"File":"VAE.R","Line":"6","Method":{"Method":"vae_embedding","Module":"declare_function","Namespace":"SMRUCC\/R#"}}},"description":"","details":"","examples":null,"keywords":[],"parameters":[{"name":"x","text":"a gcmodeller HTS matrix object"},{"name":"dims","text":"the embedding dimension size"}],"returns":null,"see_also":null,"title":"create single cell matrix embedding via VAE"}}